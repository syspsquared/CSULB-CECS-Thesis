\section{Local Repository}\label{sec:local_repository}
\subsection{Background}
One of the future changes we could make is implementing a local software repository for our given Linux distribution.  A repository contains software packages and updates supported for a given distribution.  Whenever we build a master image or update it, it must go out to a distribution repository for what we need.  This can generate a huge amount of bandwidth for large packages and update request lists.  In bandwidth limited environments, it would be a good idea to create a local repository on a server that workstations and servers can pull updates from instead of going out to the Internet.  This server would service these requests.  The reason we could potentially need it is because our workstations are not being updated during the semester.  For that, all 90 workstations would have to download the same set of updates.  This would cause unneeded and excessive bandwidth requests against the campus routers.  

\subsection{Possible Setups}
There are two types of repository servers that we can use.  A repository mirror downloads all packages and updates from a remote repository and stores them locally.  It updates itself periodically to be current.  It initially requires significant bandwidth resources.  The currently mirror for Ubuntu requires about 30 GB.  This means we need that much hard disk space plus some extra in case the image gets larger.  Disk space is les of a problem than bandwidth though.  If the appropriate approvals from the university technology administrators can be obtained for the initial bandwidth use, it will prevent the need for more bandwidth later.  There will still be a need for some significantly sized bandwidth during updates, but it will be minimal.  

\vfill\eject

The other method is a repository cache.  Rather than mirroring an entire repository, this server acts as a middleman for repository requests.  Clients make a request to it for packages and updates.  It goes out to the remote repository and downloads it.  It then allows the client to download the package from it.  It does not remove the package though.  Instead, it caches it locally in case other clients need the same package.  Thus, if all 90 workstations need the same package, it is only downloaded once to the repository cache server who makes it available on the local network.  

We do not have a set of instructions for building such a server.  However, we know it requires that an apache webserver be set up because client machines download via the standard web protocol.  This may seem insecure, but the packages are one-way hashed and the matching hashes are downloaded initially via a secure connection and compared.  This also helps in the event of data corruption.  The repository mirror or cache is then shared via the apache web directory.  All clients can then be pointed to the webserver as their target repository.  In the case of mirroring, the last step is to set up periodic synchronization so that the local repository remains current.  We assume this is done automatically but a crontab entry can be created if necessary.

\subsection{Why Local Repositories Not Needed}
We do not use a local repository as of this writing.  For security reasons, our labs are relatively isolated from the rest of the world.  We therefore do not need immediate automatic updates.  This could become an issue if we choose a more targeted distribution, but we have not seen a security incident in our Linux labs as of yet (we are far more worried about our Windows environment).  The other reason we hesitate to implement it is because some software updates can break a course curriculum software.  For example, if our major development IDE Eclipse were to get an update mid-semester that changes its interface or breaks it, we would have confusion from the students and anger from the faculty.  Even security updates could potentially cause issues.  The reason we would consider it is in case a critical package is needed mid-semester that no one told us about.  Rather than clone the entire lab again, we would just need to run the package installation tool on the required workstations via an ssh push.  However, so far the need for it is mitigated by the fact that we build to a single master image and clone. This has been sufficient so far, but it would be efficient to be able to update mid-semester if needed without taking down all of the workstations to perform the cloning. 
